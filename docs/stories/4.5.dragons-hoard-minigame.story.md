# Story 4.5: Dragon's Hoard Minigame

## User Story
**As a** User,  
**I want** to play a Quiplash-style minigame called "Dragon's Hoard" where I create cursed loot items and vote on the best ones with my party,  
**so that** I can earn rewards, build shared party lore, and have fun after completing our assessments.

## Acceptance Criteria

### Core Functionality
1. **AC1**: A "Dragon's Hoard" minigame is accessible from the party lobby, but only after all non-hireling party members have completed their assessments
2. **AC2**: Players receive two themed prompts each and create cursed/funny loot items with names and descriptions
3. **AC3**: Created loot items are paired in head-to-head matchups for anonymous voting by all non-creators
4. **AC4**: Voting uses a dragon vote tiebreaker for small groups (1-2 voters) and human votes for larger groups
5. **AC5**: Winning loot is added to the party's persistent Dragon's Hoard collection
6. **AC6**: Players earn XP and achievements for participation, wins, and creative loot
7. **AC7**: The minigame is repeatable - players can play multiple rounds in the same party session
8. **AC8**: The minigame has a responsive interface that works well on both desktop and mobile
9. **AC9**: The minigame architecture is designed to be reusable for future minigames (like Changeling)

### Technical Requirements
10. **AC10**: Implement reusable minigame framework with shared database tables and components
11. **AC11**: Create prompt pool system with themed categories and player name personalization
12. **AC12**: Implement round-robin pairing algorithm for loot matchups
13. **AC13**: Design voting system with real-time updates and dragon vote tiebreaker
14. **AC14**: Create persistent hoard collection that grows with each game session
15. **AC15**: Integrate with existing achievement and avatar systems for rewards
16. **AC16**: Implement access control to ensure minigame is only available after all non-hireling members complete assessments
17. **AC17**: Design reusable minigame framework for future minigames
18. **AC18**: Implement repeatable game sessions within the same party

## Requirements from Other Documents

### From PRD (docs/prd.md)
- **User Story**: As a User, I want to play a fun minigame called "Dragon's Hoard" to earn bonus rewards and enhance my party experience.
- **Technical Notes**: Standalone minigame with reward integration into existing systems
- **Dependencies**: Story 4.3 (Achievement System), Story 4.4 (Avatar System)

### From Ideas Document (docs/Ideas)
- **Original Concept**: "party members take turns distributing loot from the dragon's hoard to other members of the party. Loot always has weird or funny effects"
- **Quiplash Variation**: "A variation on this could be like Quiplash where multiple players generate loot and players vote on which is the best/worst" ✅ **IMPLEMENTED**

## Dependencies
- **Story 4.3**: Achievement System ✅ (Complete)
- **Story 4.4**: Avatar System ✅ (Complete)
- **Epic 2**: Questionnaire Engine ✅ (Complete - for potential data integration)

## Technical Notes
- Quiplash-style social minigame with reusable framework architecture
- Leverages existing achievement and avatar unlock mechanisms
- Real-time voting and results with WebSocket integration
- Persistent hoard collection builds party lore over time
- Framework designed for easy addition of future minigames (Changeling)

## Test Coverage Requirements
- **TC1**: Unit tests for loot creation and pairing algorithms
- **TC2**: Integration tests for voting system and real-time updates
- **TC3**: API tests for minigame session management and persistence
- **TC4**: Component tests for all minigame UI components
- **TC5**: Database tests for minigame framework and Dragon's Hoard tables
- **TC6**: Integration tests for minigame systems (as noted in Story 5.5)

---

## Dev Agent Record

### File List
- **To be created**: `src/app/party/[id]/minigame/[type]/page.tsx` (minigame routing)
- **To be created**: `src/components/minigame/BaseMinigameComponent.tsx` (framework)
- **To be created**: `src/components/minigame/DragonsHoardGame.tsx` (specific game)
- **To be created**: `src/components/minigame/PromptDisplay.tsx`
- **To be created**: `src/components/minigame/LootCreation.tsx`
- **To be created**: `src/components/minigame/LootMatchup.tsx`
- **To be created**: `src/components/minigame/VotingInterface.tsx`
- **To be created**: `src/components/minigame/ResultsDisplay.tsx`
- **To be created**: `src/components/minigame/HoardCollection.tsx`
- **To be created**: `src/hooks/useMinigameAccess.ts`
- **To be created**: `src/hooks/useMinigameSession.ts`
- **To be created**: `src/lib/minigameFramework.ts`
- **To be created**: `src/lib/dragonsHoardGame.ts`
- **To be created**: `src/types/minigame.ts`
- **To be created**: `src/types/dragonsHoard.ts`
- **To be modified**: `database/init.sql` (add minigame framework tables)
- **To be created**: `database/migrations/YYYYMMDD_create_minigame_framework.sql`
- **To be created**: `database/migrations/YYYYMMDD_create_dragons_hoard_tables.sql`

### Completion Notes
*To be filled during implementation*

### Change Log
*To be updated during development*

### Definition of Done Checklist

1. **Requirements Met:**
   - [ ] All functional requirements specified in the story are implemented
   - [ ] All acceptance criteria defined in the story are met
2. **Coding Standards & Project Structure:**
   - [ ] All new/modified code strictly adheres to Operational Guidelines
   - [ ] All new/modified code aligns with Project Structure
   - [ ] Adherence to Tech Stack for technologies/versions used
   - [ ] Adherence to Api Reference and Data Models
   - [ ] Basic security best practices applied for new/modified code
   - [ ] No new linter errors or warnings introduced
   - [ ] Code is well-commented where necessary
3. **Testing:**
   - [ ] All required unit tests as per the story and Operational Guidelines Testing Strategy are implemented
   - [ ] All required integration tests (if applicable) as per the story and Operational Guidelines Testing Strategy are implemented
   - [ ] All tests (unit, integration, E2E if applicable) pass successfully
   - [ ] Test coverage meets project standards (if defined)
4. **Functionality & Verification:**
   - [ ] Functionality has been manually verified by the developer
   - [ ] Edge cases and potential error conditions considered and handled gracefully
5. **Story Administration:**
   - [ ] All tasks within the story file are marked as complete
   - [ ] Any clarifications or decisions made during development are documented in the story file
   - [ ] The story wrap up section has been completed with notes of changes or information relevant to the next story or overall project, the agent model that was primarily used during development, and the changelog of any changes is properly updated
6. **Dependencies, Build & Configuration:**
   - [ ] Project builds successfully without errors
   - [ ] Project linting passes
   - [ ] No new dependencies were added (or new dependencies are documented)
7. **Documentation (If Applicable):**
   - [ ] Relevant inline code documentation for new public APIs or complex logic is complete
   - [ ] Technical documentation (e.g., READMEs, system diagrams) updated if significant architectural changes were made

### Final Confirmation
- [ ] I, the Developer Agent, confirm that all applicable items above have been addressed

---

## QA Results

### Review Date: *To be filled*
### Reviewed By: *To be filled*

### Code Quality Assessment
*To be filled during QA review*

### Compliance Check
- Coding Standards: [ ]
- Project Structure: [ ]
- Testing Strategy: [ ]
- All ACs Met: [ ]

### Final Status
*[ ] To be determined*

---

## Game Design Specification

### Core Game Mechanics
**Dragon's Hoard** is a Quiplash-style party mini-game where players invent cursed or funny loot items based on themed prompts. Loot then goes head-to-head in pairs, with the group voting to decide which treasures are worthy of being added to the party's hoard.

#### Gameplay Flow
1. **Prompt Assignment**
   - Each player is given two loot prompts
   - Prompts are drawn from a pool that includes fantasy-flavored setups
   - Prompts can reference monsters, locations, or even other party members by name
   - Example prompts:
     - "This is a cursed item that was once an heirloom of {player_name}'s great grandma."
     - "This treasure will definitely sell well at the goblin tavern."
     - "The dragon hid this one for a reason — what is it?"
     - "This weapon is only powerful when used to cook."

2. **Loot Creation**
   - Each player creates two loot items (name + optional short description)
   - Example: "The Goblin Keg Tap of Eternal Foam — you'll never stop burping."

3. **Pairing Loot-Offs**
   - Loot is entered into head-to-head matchups against other players' items
   - Example with 4 players:
     - A1 vs. C1
     - A2 vs. D1
     - B1 vs. D2
     - B2 vs. C2
   - This ensures variety so each player competes multiple times against different opponents

4. **Voting Phase**
   - Loot pairs are revealed anonymously, side by side
   - All non-creators vote on which loot wins
   - Small group solution:
     - If there are only 1–2 voters, a "dragon vote" (random or AI-assisted) is added as a tiebreaker
     - In larger groups, only human votes are counted

5. **Resolution**
   - Winning loot is canonically added to the Dragon's Hoard log (a visible, growing collection for the party)
   - Players earn XP for wins, ties, and participation
   - Optional badges: "Most Cursed", "Fan Favorite", "Goblin Merchant's Pick", etc.

### Treasure Types and Effects
- **Cursed Items**: Items with humorous negative effects
- **Weapons**: Combat items with silly or unexpected properties
- **Trinkets**: Small items with magical or mundane effects
- **Consumables**: Items meant to be used (often with funny consequences)
- **Artifacts**: Legendary items with elaborate backstories

### Reward Integration
- **XP System**: Players earn experience points for participation and wins
- **Achievement Unlocks**: Special achievements for creative loot, winning streaks, etc.
- **Avatar Parts**: Unlock special dragon-themed avatar accessories
- **Party Bonuses**: Winning loot could provide temporary party-wide benefits
- **Hoard Collection**: Visual display of all collected treasures as party lore

### UI/UX Considerations
- **Prompt Display**: Clear, themed presentation of loot creation prompts
- **Loot Creation**: Simple text input with optional description field
- **Voting Interface**: Side-by-side comparison with clear voting buttons
- **Results Display**: Animated reveal of winning loot with celebration effects
- **Hoard Log**: Scrollable collection of all party's acquired treasures
- **Mobile Responsive**: Touch-friendly interface for mobile devices

### Technical Architecture
- **Prompt Pool**: JSON file with placeholders for player names, monsters, locations
- **Pairing Algorithm**: Round-robin or random shuffle for loot matchups
- **Dragon Vote**: Narrative presentation of AI/random tiebreaker votes
- **Real-time Updates**: WebSocket integration for live voting and results
- **Progress Persistence**: Save game state and hoard collection to database
- **Replayability**: Multiple prompt pools and difficulty settings

### Database Schema Requirements
- **dragons_hoard_games**: Track individual game sessions
- **dragons_hoard_loot**: Store created loot items with metadata
- **dragons_hoard_votes**: Record voting results and matchups
- **dragons_hoard_hoard**: Persistent collection of winning loot per party
- **dragons_hoard_prompts**: Configurable prompt pool with placeholders

### Reusable Minigame Framework
To support future minigames like Changeling, the architecture should include:

#### Core Minigame Interface
- **Base Minigame Component**: Abstract component that handles common minigame functionality
- **Minigame State Management**: Reusable state management for game sessions, rounds, and progress
- **Access Control Hook**: Shared logic for determining when minigames are available
- **Reward Integration Service**: Common service for integrating with achievement and avatar systems

#### Shared Database Tables
- **minigame_sessions**: Generic table for tracking any minigame session
- **minigame_participants**: Track who participated in each session
- **minigame_rewards**: Generic reward tracking system
- **minigame_config**: Configuration for different minigame types

#### Access Control Requirements
- **Assessment Completion Check**: Minigames only available when all non-hireling members have status 'Finished'
- **Party State Validation**: Ensure party is in appropriate state for minigames
- **Repeatable Sessions**: Allow multiple rounds of the same minigame within a party session
- **Session Management**: Track active minigame sessions and prevent conflicts

### Implementation Strategy
1. **Phase 1**: Build reusable minigame framework and base components
2. **Phase 2**: Implement Dragon's Hoard using the framework
3. **Phase 3**: Framework ready for Changeling and future minigames

## Implementation Plan

### Phase 1: Reusable Minigame Framework (Foundation)
**Goal**: Create the shared infrastructure that both Dragon's Hoard and future minigames will use

#### Database Schema
- [ ] Create `minigame_sessions` table (id, party_id, minigame_type, status, created_at, completed_at)
- [ ] Create `minigame_participants` table (session_id, user_id, joined_at, left_at)
- [ ] Create `minigame_rewards` table (id, session_id, user_id, reward_type, reward_data, awarded_at)
- [ ] Create `minigame_config` table (minigame_type, config_key, config_value)
- [ ] Add minigame access control to existing party member status checks

#### Core Services & Hooks
- [ ] Create `useMinigameAccess` hook - checks if minigames are available for a party
- [ ] Create `useMinigameSession` hook - manages active minigame sessions
- [ ] Create `MinigameRewardService` - handles reward distribution and integration
- [ ] Create `BaseMinigameComponent` - abstract component with common functionality
- [ ] Create minigame routing structure (`/party/[id]/minigame/[type]`)

#### Access Control
- [ ] Add minigame availability check to party lobby
- [ ] Create "Play Minigames" button that only appears when assessments are complete
- [ ] Implement party state validation for minigame access

### Phase 2: Dragon's Hoard Implementation
**Goal**: Build the actual Dragon's Hoard game using the framework

#### Game-Specific Database Tables
- [ ] Create `dragons_hoard_prompts` table (id, prompt_text, category, is_active)
- [ ] Create `dragons_hoard_loot` table (id, session_id, creator_id, prompt_id, name, description, created_at)
- [ ] Create `dragons_hoard_matchups` table (id, session_id, loot_a_id, loot_b_id, round_number, status)
- [ ] Create `dragons_hoard_votes` table (id, matchup_id, voter_id, voted_for_loot_id, created_at)
- [ ] Create `dragons_hoard_hoard` table (id, party_id, loot_id, added_at) - persistent collection

#### Game Logic & Components
- [ ] Create `DragonsHoardGame` component with game flow management
- [ ] Create `PromptDisplay` component for showing loot creation prompts
- [ ] Create `LootCreation` component for item creation interface
- [ ] Create `LootMatchup` component for head-to-head voting
- [ ] Create `VotingInterface` component for casting votes
- [ ] Create `ResultsDisplay` component for showing winners
- [ ] Create `HoardCollection` component for displaying party's treasures

#### Game Flow Implementation
- [ ] Implement prompt assignment logic (2 prompts per player)
- [ ] Implement loot creation and submission
- [ ] Implement round-robin pairing algorithm
- [ ] Implement voting system with dragon vote tiebreaker
- [ ] Implement results calculation and hoard addition
- [ ] Implement XP and achievement rewards

#### UI/UX Polish
- [ ] Create responsive design for mobile and desktop
- [ ] Add animations for loot reveals and voting
- [ ] Create themed visual design (dragon/treasure aesthetic)
- [ ] Implement real-time updates for live voting
- [ ] Add sound effects and visual feedback

### Phase 3: Integration & Testing
**Goal**: Connect everything together and ensure it works smoothly

#### Integration Points
- [ ] Connect minigame rewards to existing achievement system
- [ ] Connect minigame rewards to existing avatar system
- [ ] Add minigame access to party lobby navigation
- [ ] Implement repeatable sessions (play again functionality)
- [ ] Add minigame history and statistics

#### Testing & Polish
- [ ] Write unit tests for game logic and components
- [ ] Write integration tests for minigame framework
- [ ] Test with various party sizes (2-6 players)
- [ ] Test mobile responsiveness
- [ ] Test real-time updates and WebSocket integration
- [ ] Performance testing for multiple concurrent games

#### Prompt Pool & Content
- [ ] Create initial prompt pool with 50+ prompts across categories
- [ ] Add prompt categories: Cursed Items, Goblin Market, Dragon Secrets, Cooking Weapons
- [ ] Implement prompt personalization (insert player names, party details)
- [ ] Add seasonal or themed prompt packs

### Phase 4: Framework Readiness
**Goal**: Ensure the framework is ready for Changeling and future minigames

#### Documentation & Examples
- [ ] Document minigame framework API and usage
- [ ] Create example minigame implementation
- [ ] Document database schema and relationships
- [ ] Create developer guide for adding new minigames

#### Framework Validation
- [ ] Verify framework can easily support Changeling minigame
- [ ] Test framework with mock "test minigame" to ensure flexibility
- [ ] Optimize shared components for different game types
- [ ] Ensure reward system works with various minigame types

### Success Criteria
- [ ] Dragon's Hoard is fully playable and fun
- [ ] Framework supports easy addition of new minigames
- [ ] All acceptance criteria are met
- [ ] Mobile and desktop experiences are polished
- [ ] Integration with existing systems works seamlessly
- [ ] Performance is smooth with multiple concurrent games

---

## Unused Scraps
*Content that was considered but doesn't align with the current Quiplash-style design*

### Original Task List Requirements (Superseded)
- Task 1: Create minigame interface
- Task 2: Implement treasure collection mechanic  
- Task 3: Design reward system integration
- Task 4: Create responsive minigame UI
- Task 5: Implement progress saving
- Task 6: Add multiple difficulty levels

### Original TODO List Requirements (Superseded)
- Create minigame interface accessible from main menu or party lobby
- Implement treasure collection mechanic with various collectible items
- Design reward system that integrates with avatar parts and achievements
- Create responsive interface that works on desktop and mobile
- Implement progress saving and session persistence
- Add multiple levels or difficulty settings for engagement
- Integrate rewards with existing achievement and avatar systems

### Original Database Schema (Superseded)
- **dragons_hoard_games**: Track individual game sessions
- **dragons_hoard_loot**: Store created loot items with metadata
- **dragons_hoard_votes**: Record voting results and matchups
- **dragons_hoard_hoard**: Persistent collection of winning loot per party
- **dragons_hoard_prompts**: Configurable prompt pool with placeholders

*Note: These were replaced by the comprehensive minigame framework approach*
